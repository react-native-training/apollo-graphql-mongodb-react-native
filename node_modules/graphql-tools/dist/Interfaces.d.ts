/// <reference types="typed-graphql" />
import { GraphQLSchema, GraphQLFieldDefinition, GraphQLResult, GraphQLType, GraphQLFieldResolveFn, GraphQLIsTypeOfFn, GraphQLTypeResolveFn } from 'graphql';
export interface IResolverValidationOptions {
    requireResolversForArgs?: boolean;
    requireResolversForNonScalar?: boolean;
    requireResolversForAllFields?: boolean;
}
export interface IResolverOptions {
    resolve?: GraphQLFieldResolveFn;
    __resolveType?: GraphQLTypeResolveFn;
    __isTypeOf?: GraphQLIsTypeOfFn;
}
export declare type ITypedef = (() => ITypedef[]) | string;
export declare type ITypeDefinitions = ITypedef | ITypedef[];
export declare type IResolverObject = {
    [key: string]: GraphQLFieldResolveFn | IResolverOptions;
};
export interface IResolvers {
    [key: string]: (() => any) | IResolverObject;
}
export interface ILogger {
    log: (message: string | Error) => void;
}
export interface IConnectorCls {
    new (context?: any): any;
}
export declare type IConnectorFn = (context?: any) => any;
export declare type IConnector = IConnectorCls | IConnectorFn;
export declare type IConnectors = {
    [key: string]: IConnector;
};
export interface IExecutableSchemaDefinition {
    typeDefs: ITypeDefinitions;
    resolvers: IResolvers;
    connectors?: IConnectors;
    logger?: ILogger;
    allowUndefinedInResolve?: boolean;
    resolverValidationOptions?: IResolverValidationOptions;
}
export declare type IFieldIteratorFn = (fieldDef: GraphQLFieldDefinition, typeName: string, fieldName: string) => void;
export declare type IMockFn = GraphQLFieldResolveFn;
export declare type IMocks = {
    [key: string]: IMockFn;
};
export declare type IMockTypeFn = (type: GraphQLType, typeName?: string, fieldName?: string) => GraphQLFieldResolveFn;
export interface IMockOptions {
    schema: GraphQLSchema;
    mocks?: IMocks;
    preserveResolvers?: boolean;
}
export interface IMockServer {
    query: (query: string, vars?: {
        [key: string]: any;
    }) => Promise<GraphQLResult>;
}
